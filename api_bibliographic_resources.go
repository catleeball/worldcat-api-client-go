/*
WorldCat Search API v. 2

Searching of WorldCat

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// BibliographicResourcesApiService BibliographicResourcesApi service
type BibliographicResourcesApiService service

type ApiRetrieveBibRequest struct {
	ctx        context.Context
	ApiService *BibliographicResourcesApiService
	oclcNumber int64
	accept     *string
}

// Content Type the client supports and is requesting (application/json currently supported)
func (r ApiRetrieveBibRequest) Accept(accept string) ApiRetrieveBibRequest {
	r.accept = &accept
	return r
}

func (r ApiRetrieveBibRequest) Execute() (*SearchBibs200ResponseBibRecordsInner, *http.Response, error) {
	return r.ApiService.RetrieveBibExecute(r)
}

/*
RetrieveBib Retrieve specific Bibliographic Resource

Retrieve specific Bibliographic Resource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param oclcNumber record OCLC number
	@return ApiRetrieveBibRequest
*/
func (a *BibliographicResourcesApiService) RetrieveBib(ctx context.Context, oclcNumber int64) ApiRetrieveBibRequest {
	return ApiRetrieveBibRequest{
		ApiService: a,
		ctx:        ctx,
		oclcNumber: oclcNumber,
	}
}

// Execute executes the request
//
//	@return SearchBibs200ResponseBibRecordsInner
func (a *BibliographicResourcesApiService) RetrieveBibExecute(r ApiRetrieveBibRequest) (*SearchBibs200ResponseBibRecordsInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SearchBibs200ResponseBibRecordsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BibliographicResourcesApiService.RetrieveBib")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bibs/{oclcNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"oclcNumber"+"}", url.PathEscape(parameterValueToString(r.oclcNumber, "oclcNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveBriefBibRequest struct {
	ctx                    context.Context
	ApiService             *BibliographicResourcesApiService
	oclcNumber             int64
	accept                 *string
	showHoldingsIndicators *bool
}

// Content Type the client supports and is requesting (application/json currently supported)
func (r ApiRetrieveBriefBibRequest) Accept(accept string) ApiRetrieveBriefBibRequest {
	r.accept = &accept
	return r
}

// whether or not to show holdings indicators in response
func (r ApiRetrieveBriefBibRequest) ShowHoldingsIndicators(showHoldingsIndicators bool) ApiRetrieveBriefBibRequest {
	r.showHoldingsIndicators = &showHoldingsIndicators
	return r
}

func (r ApiRetrieveBriefBibRequest) Execute() (*FindBibRetainedHoldings200ResponseBriefRecordsInner, *http.Response, error) {
	return r.ApiService.RetrieveBriefBibExecute(r)
}

/*
RetrieveBriefBib Retrieve specific Bibliographic Resource

Retrieve specific Bibliographic Resource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param oclcNumber record OCLC number
	@return ApiRetrieveBriefBibRequest
*/
func (a *BibliographicResourcesApiService) RetrieveBriefBib(ctx context.Context, oclcNumber int64) ApiRetrieveBriefBibRequest {
	return ApiRetrieveBriefBibRequest{
		ApiService: a,
		ctx:        ctx,
		oclcNumber: oclcNumber,
	}
}

// Execute executes the request
//
//	@return FindBibRetainedHoldings200ResponseBriefRecordsInner
func (a *BibliographicResourcesApiService) RetrieveBriefBibExecute(r ApiRetrieveBriefBibRequest) (*FindBibRetainedHoldings200ResponseBriefRecordsInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FindBibRetainedHoldings200ResponseBriefRecordsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BibliographicResourcesApiService.RetrieveBriefBib")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/brief-bibs/{oclcNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"oclcNumber"+"}", url.PathEscape(parameterValueToString(r.oclcNumber, "oclcNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showHoldingsIndicators != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showHoldingsIndicators", r.showHoldingsIndicators, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveOtherEditionsRequest struct {
	ctx                    context.Context
	ApiService             *BibliographicResourcesApiService
	oclcNumber             int64
	accept                 *string
	deweyNumber            *[]string
	datePublished          *[]string
	heldByGroup            *string
	heldBy                 *string
	heldBySymbol           *[]string
	heldByInstitutionID    *[]int32
	inLanguage             *[]string
	inCatalogLanguage      *string
	materialType           *string
	catalogSource          *string
	itemType               *[]string
	itemSubType            *[]string
	retentionCommitments   *bool
	spProgram              *string
	genre                  *string
	topic                  *string
	subtopic               *string
	audience               *string
	content                *[]string
	openAccess             *bool
	peerReviewed           *bool
	facets                 *[]string
	groupVariantRecords    *bool
	preferredLanguage      *string
	showHoldingsIndicators *bool
	offset                 *int32
	limit                  *int32
	orderBy                *string
}

// Content Type the client supports and is requesting (application/json currently supported)
func (r ApiRetrieveOtherEditionsRequest) Accept(accept string) ApiRetrieveOtherEditionsRequest {
	r.accept = &accept
	return r
}

// Limiter to restrict the response to the specified dewey classification number(s). For multiple values repeat the URL parameter. (dd index)
func (r ApiRetrieveOtherEditionsRequest) DeweyNumber(deweyNumber []string) ApiRetrieveOtherEditionsRequest {
	r.deweyNumber = &deweyNumber
	return r
}

// Limiter to restrict the response to one or more dates or to a range (in index). (2000, 2000-2010, 1990,1991)
func (r ApiRetrieveOtherEditionsRequest) DatePublished(datePublished []string) ApiRetrieveOtherEditionsRequest {
	r.datePublished = &datePublished
	return r
}

// Restrict to holdings held by Group Symbol
func (r ApiRetrieveOtherEditionsRequest) HeldByGroup(heldByGroup string) ApiRetrieveOtherEditionsRequest {
	r.heldByGroup = &heldByGroup
	return r
}

// Institution Symbol
// Deprecated
func (r ApiRetrieveOtherEditionsRequest) HeldBy(heldBy string) ApiRetrieveOtherEditionsRequest {
	r.heldBy = &heldBy
	return r
}

// Institution Symbol
func (r ApiRetrieveOtherEditionsRequest) HeldBySymbol(heldBySymbol []string) ApiRetrieveOtherEditionsRequest {
	r.heldBySymbol = &heldBySymbol
	return r
}

// Institution registryId
func (r ApiRetrieveOtherEditionsRequest) HeldByInstitutionID(heldByInstitutionID []int32) ApiRetrieveOtherEditionsRequest {
	r.heldByInstitutionID = &heldByInstitutionID
	return r
}

// Limiter to restrict the response to the single specified language (ln index). (eng, fre, ger)
func (r ApiRetrieveOtherEditionsRequest) InLanguage(inLanguage []string) ApiRetrieveOtherEditionsRequest {
	r.inLanguage = &inLanguage
	return r
}

// Limiter to restrict the response to the single specified cataloging language (ll index). (dut, eng)
func (r ApiRetrieveOtherEditionsRequest) InCatalogLanguage(inCatalogLanguage string) ApiRetrieveOtherEditionsRequest {
	r.inCatalogLanguage = &inCatalogLanguage
	return r
}

// Limiter to restrict the response to the specified material type (mt index). (URL, LPS)
func (r ApiRetrieveOtherEditionsRequest) MaterialType(materialType string) ApiRetrieveOtherEditionsRequest {
	r.materialType = &materialType
	return r
}

// Limiter to restrict the response to the single OCLC symbol as the cataloging source (cs index). (OSL)
func (r ApiRetrieveOtherEditionsRequest) CatalogSource(catalogSource string) ApiRetrieveOtherEditionsRequest {
	r.catalogSource = &catalogSource
	return r
}

// Limiter to restrict the response to the single specified OCLC top-level facet type (x0 index). (book, image)
func (r ApiRetrieveOtherEditionsRequest) ItemType(itemType []string) ApiRetrieveOtherEditionsRequest {
	r.itemType = &itemType
	return r
}

// Limiter to restrict the response to the single specified OCLC sub facet type (x1 index). (dvd, digital)
func (r ApiRetrieveOtherEditionsRequest) ItemSubType(itemSubType []string) ApiRetrieveOtherEditionsRequest {
	r.itemSubType = &itemSubType
	return r
}

// Limiter to restrict the response to bibliographic records with a retention commitment (l8 index).
func (r ApiRetrieveOtherEditionsRequest) RetentionCommitments(retentionCommitments bool) ApiRetrieveOtherEditionsRequest {
	r.retentionCommitments = &retentionCommitments
	return r
}

// Limiter to restrict the response to bibliographic records associated with a particular shared print program (l8 index).
func (r ApiRetrieveOtherEditionsRequest) SpProgram(spProgram string) ApiRetrieveOtherEditionsRequest {
	r.spProgram = &spProgram
	return r
}

// Genre to limit results to (ge index)
func (r ApiRetrieveOtherEditionsRequest) Genre(genre string) ApiRetrieveOtherEditionsRequest {
	r.genre = &genre
	return r
}

// topic to limit results to (s0 index). Based on OCLC Conspectus Division
func (r ApiRetrieveOtherEditionsRequest) Topic(topic string) ApiRetrieveOtherEditionsRequest {
	r.topic = &topic
	return r
}

// subtopic to limit results to (s1 index). Based on OCLC Conspectus Category
func (r ApiRetrieveOtherEditionsRequest) Subtopic(subtopic string) ApiRetrieveOtherEditionsRequest {
	r.subtopic = &subtopic
	return r
}

// Audience to limit results to
func (r ApiRetrieveOtherEditionsRequest) Audience(audience string) ApiRetrieveOtherEditionsRequest {
	r.audience = &audience
	return r
}

// Content to limit results to
func (r ApiRetrieveOtherEditionsRequest) Content(content []string) ApiRetrieveOtherEditionsRequest {
	r.content = &content
	return r
}

// filter to just open access content
func (r ApiRetrieveOtherEditionsRequest) OpenAccess(openAccess bool) ApiRetrieveOtherEditionsRequest {
	r.openAccess = &openAccess
	return r
}

// filter to just peer reviewed content
func (r ApiRetrieveOtherEditionsRequest) PeerReviewed(peerReviewed bool) ApiRetrieveOtherEditionsRequest {
	r.peerReviewed = &peerReviewed
	return r
}

// The requested list of facets requested in the response
func (r ApiRetrieveOtherEditionsRequest) Facets(facets []string) ApiRetrieveOtherEditionsRequest {
	r.facets = &facets
	return r
}

// Whether or not to group variant records. Default is &#39;false&#39;
func (r ApiRetrieveOtherEditionsRequest) GroupVariantRecords(groupVariantRecords bool) ApiRetrieveOtherEditionsRequest {
	r.groupVariantRecords = &groupVariantRecords
	return r
}

// language user would prefer metadata description in
func (r ApiRetrieveOtherEditionsRequest) PreferredLanguage(preferredLanguage string) ApiRetrieveOtherEditionsRequest {
	r.preferredLanguage = &preferredLanguage
	return r
}

// whether or not to show holdings indicators in response
func (r ApiRetrieveOtherEditionsRequest) ShowHoldingsIndicators(showHoldingsIndicators bool) ApiRetrieveOtherEditionsRequest {
	r.showHoldingsIndicators = &showHoldingsIndicators
	return r
}

// start position of the bib records to return (0 based), default 0
func (r ApiRetrieveOtherEditionsRequest) Offset(offset int32) ApiRetrieveOtherEditionsRequest {
	r.offset = &offset
	return r
}

// maximum number of records to return, maximum 50, default 10
func (r ApiRetrieveOtherEditionsRequest) Limit(limit int32) ApiRetrieveOtherEditionsRequest {
	r.limit = &limit
	return r
}

// how to sort the edition resultsresults
func (r ApiRetrieveOtherEditionsRequest) OrderBy(orderBy string) ApiRetrieveOtherEditionsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiRetrieveOtherEditionsRequest) Execute() (*FindBibRetainedHoldings200Response, *http.Response, error) {
	return r.ApiService.RetrieveOtherEditionsExecute(r)
}

/*
RetrieveOtherEditions Retrieve Other Editions related to a particular Bibliographic Resource

Retrieve Other Editions related to a particular Bibliographic Resource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param oclcNumber record OCLC number
	@return ApiRetrieveOtherEditionsRequest
*/
func (a *BibliographicResourcesApiService) RetrieveOtherEditions(ctx context.Context, oclcNumber int64) ApiRetrieveOtherEditionsRequest {
	return ApiRetrieveOtherEditionsRequest{
		ApiService: a,
		ctx:        ctx,
		oclcNumber: oclcNumber,
	}
}

// Execute executes the request
//
//	@return FindBibRetainedHoldings200Response
func (a *BibliographicResourcesApiService) RetrieveOtherEditionsExecute(r ApiRetrieveOtherEditionsRequest) (*FindBibRetainedHoldings200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FindBibRetainedHoldings200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BibliographicResourcesApiService.RetrieveOtherEditions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/brief-bibs/{oclcNumber}/other-editions"
	localVarPath = strings.Replace(localVarPath, "{"+"oclcNumber"+"}", url.PathEscape(parameterValueToString(r.oclcNumber, "oclcNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deweyNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deweyNumber", r.deweyNumber, "csv")
	}
	if r.datePublished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "datePublished", r.datePublished, "csv")
	}
	if r.heldByGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heldByGroup", r.heldByGroup, "")
	}
	if r.heldBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heldBy", r.heldBy, "")
	}
	if r.heldBySymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heldBySymbol", r.heldBySymbol, "csv")
	}
	if r.heldByInstitutionID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heldByInstitutionID", r.heldByInstitutionID, "csv")
	}
	if r.inLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inLanguage", r.inLanguage, "csv")
	}
	if r.inCatalogLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inCatalogLanguage", r.inCatalogLanguage, "")
	}
	if r.materialType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "materialType", r.materialType, "")
	}
	if r.catalogSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "catalogSource", r.catalogSource, "")
	}
	if r.itemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemType", r.itemType, "csv")
	}
	if r.itemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemSubType", r.itemSubType, "csv")
	}
	if r.retentionCommitments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retentionCommitments", r.retentionCommitments, "")
	}
	if r.spProgram != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spProgram", r.spProgram, "")
	}
	if r.genre != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "genre", r.genre, "")
	}
	if r.topic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "topic", r.topic, "")
	}
	if r.subtopic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtopic", r.subtopic, "")
	}
	if r.audience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audience", r.audience, "")
	}
	if r.content != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "content", r.content, "csv")
	}
	if r.openAccess != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "openAccess", r.openAccess, "")
	}
	if r.peerReviewed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "peerReviewed", r.peerReviewed, "")
	}
	if r.facets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "facets", r.facets, "csv")
	}
	if r.groupVariantRecords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupVariantRecords", r.groupVariantRecords, "")
	}
	if r.preferredLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preferredLanguage", r.preferredLanguage, "")
	}
	if r.showHoldingsIndicators != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showHoldingsIndicators", r.showHoldingsIndicators, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchBibsRequest struct {
	ctx                  context.Context
	ApiService           *BibliographicResourcesApiService
	q                    *string
	accept               *string
	deweyNumber          *[]string
	datePublished        *[]string
	heldByGroup          *string
	heldBy               *string
	heldBySymbol         *[]string
	heldByInstitutionID  *[]int32
	inLanguage           *[]string
	inCatalogLanguage    *string
	materialType         *string
	catalogSource        *string
	itemType             *[]string
	itemSubType          *[]string
	retentionCommitments *bool
	spProgram            *string
	facets               *[]string
	groupRelatedEditions *bool
	groupVariantRecords  *bool
	preferredLanguage    *string
	orderBy              *string
	offset               *int32
	limit                *int32
}

// query in the form of a keyword search or fielded search, for example  (au:gazihan OR au:womacka) AND kw:java See - https://help.oclc.org/Librarian_Toolbox/Searching_WorldCat_Indexes/Bibliographic_records/Bibliographic_record_indexes/Bibliographic_record_index_lists
func (r ApiSearchBibsRequest) Q(q string) ApiSearchBibsRequest {
	r.q = &q
	return r
}

// Content Type the client supports and is requesting (application/json currently supported)
func (r ApiSearchBibsRequest) Accept(accept string) ApiSearchBibsRequest {
	r.accept = &accept
	return r
}

// Limiter to restrict the response to the specified dewey classification number(s). For multiple values repeat the URL parameter. (dd index)
func (r ApiSearchBibsRequest) DeweyNumber(deweyNumber []string) ApiSearchBibsRequest {
	r.deweyNumber = &deweyNumber
	return r
}

// Limiter to restrict the response to one or more dates or to a range (in index). (2000, 2000-2010, 1990,1991)
func (r ApiSearchBibsRequest) DatePublished(datePublished []string) ApiSearchBibsRequest {
	r.datePublished = &datePublished
	return r
}

// Restrict to holdings held by Group Symbol
func (r ApiSearchBibsRequest) HeldByGroup(heldByGroup string) ApiSearchBibsRequest {
	r.heldByGroup = &heldByGroup
	return r
}

// Institution Symbol
// Deprecated
func (r ApiSearchBibsRequest) HeldBy(heldBy string) ApiSearchBibsRequest {
	r.heldBy = &heldBy
	return r
}

// Institution Symbol
func (r ApiSearchBibsRequest) HeldBySymbol(heldBySymbol []string) ApiSearchBibsRequest {
	r.heldBySymbol = &heldBySymbol
	return r
}

// Institution registryId
func (r ApiSearchBibsRequest) HeldByInstitutionID(heldByInstitutionID []int32) ApiSearchBibsRequest {
	r.heldByInstitutionID = &heldByInstitutionID
	return r
}

// Limiter to restrict the response to the single specified language (ln index). (eng, fre, ger)
func (r ApiSearchBibsRequest) InLanguage(inLanguage []string) ApiSearchBibsRequest {
	r.inLanguage = &inLanguage
	return r
}

// Limiter to restrict the response to the single specified cataloging language (ll index). (dut, eng)
func (r ApiSearchBibsRequest) InCatalogLanguage(inCatalogLanguage string) ApiSearchBibsRequest {
	r.inCatalogLanguage = &inCatalogLanguage
	return r
}

// Limiter to restrict the response to the specified material type (mt index). (URL, LPS)
func (r ApiSearchBibsRequest) MaterialType(materialType string) ApiSearchBibsRequest {
	r.materialType = &materialType
	return r
}

// Limiter to restrict the response to the single OCLC symbol as the cataloging source (cs index). (OSL)
func (r ApiSearchBibsRequest) CatalogSource(catalogSource string) ApiSearchBibsRequest {
	r.catalogSource = &catalogSource
	return r
}

// Limiter to restrict the response to the single specified OCLC top-level facet type (x0 index). (book, image)
func (r ApiSearchBibsRequest) ItemType(itemType []string) ApiSearchBibsRequest {
	r.itemType = &itemType
	return r
}

// Limiter to restrict the response to the single specified OCLC sub facet type (x1 index). (dvd, digital)
func (r ApiSearchBibsRequest) ItemSubType(itemSubType []string) ApiSearchBibsRequest {
	r.itemSubType = &itemSubType
	return r
}

// Limiter to restrict the response to bibliographic records with a retention commitment (l8 index).
func (r ApiSearchBibsRequest) RetentionCommitments(retentionCommitments bool) ApiSearchBibsRequest {
	r.retentionCommitments = &retentionCommitments
	return r
}

// Limiter to restrict the response to bibliographic records associated with a particular shared print program (l8 index).
func (r ApiSearchBibsRequest) SpProgram(spProgram string) ApiSearchBibsRequest {
	r.spProgram = &spProgram
	return r
}

// The requested list of facets requested in the response
func (r ApiSearchBibsRequest) Facets(facets []string) ApiSearchBibsRequest {
	r.facets = &facets
	return r
}

// Whether or not to use FRBR grouping. Default is &#39;false&#39;
func (r ApiSearchBibsRequest) GroupRelatedEditions(groupRelatedEditions bool) ApiSearchBibsRequest {
	r.groupRelatedEditions = &groupRelatedEditions
	return r
}

// Whether or not to group variant records. Default is &#39;false&#39;
func (r ApiSearchBibsRequest) GroupVariantRecords(groupVariantRecords bool) ApiSearchBibsRequest {
	r.groupVariantRecords = &groupVariantRecords
	return r
}

// language user would prefer metadata description in
func (r ApiSearchBibsRequest) PreferredLanguage(preferredLanguage string) ApiSearchBibsRequest {
	r.preferredLanguage = &preferredLanguage
	return r
}

// result sort key
func (r ApiSearchBibsRequest) OrderBy(orderBy string) ApiSearchBibsRequest {
	r.orderBy = &orderBy
	return r
}

// start position of the bib records to return (0 based), default 0
func (r ApiSearchBibsRequest) Offset(offset int32) ApiSearchBibsRequest {
	r.offset = &offset
	return r
}

// maximum number of records to return, maximum 50, default 10
func (r ApiSearchBibsRequest) Limit(limit int32) ApiSearchBibsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchBibsRequest) Execute() (*SearchBibs200Response, *http.Response, error) {
	return r.ApiService.SearchBibsExecute(r)
}

/*
SearchBibs Search Bibliographic Resources

Search Bibliographic Resources. Key Indexes <table cellspacing="0"> <tbody><tr><th>Index Name</th> <th>Index Code</th> </tr> <tr><td>Author</td> <td>au</td> </tr><tr><td>Corporate/Conference Name</td> <td>cn</td> </tr><tr><td>ISBN</td> <td>bn</td> </tr><tr><td>ISSN</td> <td>in</td> </tr><tr><td>Keyword</td> <td>kw</td> </tr><tr><td>LCCN</td> <td>dn</td> </tr><tr><td>Notes</td> <td>nt</td> </tr><tr><td>OCLC Number</td> <td>sno</td> </tr><tr><td>Place of publication</td> <td>pl</td> </tr><tr><td>Publisher</td> <td>pb</td> </tr><tr><td>Series</td> <td>se</td> </tr><tr><td>Standard Number</td> <td>sn</td> </tr><tr><td>Subject</td> <td>su</td> </tr><tr><td>Title</td> <td>ti</td> </tr></tbody></table>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchBibsRequest
*/
func (a *BibliographicResourcesApiService) SearchBibs(ctx context.Context) ApiSearchBibsRequest {
	return ApiSearchBibsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SearchBibs200Response
func (a *BibliographicResourcesApiService) SearchBibsExecute(r ApiSearchBibsRequest) (*SearchBibs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SearchBibs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BibliographicResourcesApiService.SearchBibs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bibs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.q == nil {
		return localVarReturnValue, nil, reportError("q is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	if r.deweyNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deweyNumber", r.deweyNumber, "csv")
	}
	if r.datePublished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "datePublished", r.datePublished, "csv")
	}
	if r.heldByGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heldByGroup", r.heldByGroup, "")
	}
	if r.heldBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heldBy", r.heldBy, "")
	}
	if r.heldBySymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heldBySymbol", r.heldBySymbol, "csv")
	}
	if r.heldByInstitutionID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heldByInstitutionID", r.heldByInstitutionID, "csv")
	}
	if r.inLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inLanguage", r.inLanguage, "csv")
	}
	if r.inCatalogLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inCatalogLanguage", r.inCatalogLanguage, "")
	}
	if r.materialType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "materialType", r.materialType, "")
	}
	if r.catalogSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "catalogSource", r.catalogSource, "")
	}
	if r.itemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemType", r.itemType, "csv")
	}
	if r.itemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemSubType", r.itemSubType, "csv")
	}
	if r.retentionCommitments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retentionCommitments", r.retentionCommitments, "")
	}
	if r.spProgram != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spProgram", r.spProgram, "")
	}
	if r.facets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "facets", r.facets, "csv")
	}
	if r.groupRelatedEditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupRelatedEditions", r.groupRelatedEditions, "")
	}
	if r.groupVariantRecords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupVariantRecords", r.groupVariantRecords, "")
	}
	if r.preferredLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preferredLanguage", r.preferredLanguage, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchBriefBibsRequest struct {
	ctx                    context.Context
	ApiService             *BibliographicResourcesApiService
	q                      *string
	accept                 *string
	deweyNumber            *[]string
	datePublished          *[]string
	heldByGroup            *string
	heldBy                 *string
	heldBySymbol           *[]string
	heldByInstitutionID    *[]int32
	inLanguage             *[]string
	inCatalogLanguage      *string
	materialType           *string
	catalogSource          *string
	itemType               *[]string
	itemSubType            *[]string
	retentionCommitments   *bool
	spProgram              *string
	facets                 *[]string
	groupRelatedEditions   *bool
	groupVariantRecords    *bool
	preferredLanguage      *string
	showHoldingsIndicators *bool
	orderBy                *string
	offset                 *int32
	limit                  *int32
}

// query in the form of a keyword search or fielded search, for example  (au:gazihan OR au:womacka) AND kw:java See - https://help.oclc.org/Librarian_Toolbox/Searching_WorldCat_Indexes/Bibliographic_records/Bibliographic_record_indexes/Bibliographic_record_index_lists
func (r ApiSearchBriefBibsRequest) Q(q string) ApiSearchBriefBibsRequest {
	r.q = &q
	return r
}

// Content Type the client supports and is requesting (application/json currently supported)
func (r ApiSearchBriefBibsRequest) Accept(accept string) ApiSearchBriefBibsRequest {
	r.accept = &accept
	return r
}

// Limiter to restrict the response to the specified dewey classification number(s). For multiple values repeat the URL parameter. (dd index)
func (r ApiSearchBriefBibsRequest) DeweyNumber(deweyNumber []string) ApiSearchBriefBibsRequest {
	r.deweyNumber = &deweyNumber
	return r
}

// Limiter to restrict the response to one or more dates or to a range (in index). (2000, 2000-2010, 1990,1991)
func (r ApiSearchBriefBibsRequest) DatePublished(datePublished []string) ApiSearchBriefBibsRequest {
	r.datePublished = &datePublished
	return r
}

// Restrict to holdings held by Group Symbol
func (r ApiSearchBriefBibsRequest) HeldByGroup(heldByGroup string) ApiSearchBriefBibsRequest {
	r.heldByGroup = &heldByGroup
	return r
}

// Institution Symbol
// Deprecated
func (r ApiSearchBriefBibsRequest) HeldBy(heldBy string) ApiSearchBriefBibsRequest {
	r.heldBy = &heldBy
	return r
}

// Institution Symbol
func (r ApiSearchBriefBibsRequest) HeldBySymbol(heldBySymbol []string) ApiSearchBriefBibsRequest {
	r.heldBySymbol = &heldBySymbol
	return r
}

// Institution registryId
func (r ApiSearchBriefBibsRequest) HeldByInstitutionID(heldByInstitutionID []int32) ApiSearchBriefBibsRequest {
	r.heldByInstitutionID = &heldByInstitutionID
	return r
}

// Limiter to restrict the response to the single specified language (ln index). (eng, fre, ger)
func (r ApiSearchBriefBibsRequest) InLanguage(inLanguage []string) ApiSearchBriefBibsRequest {
	r.inLanguage = &inLanguage
	return r
}

// Limiter to restrict the response to the single specified cataloging language (ll index). (dut, eng)
func (r ApiSearchBriefBibsRequest) InCatalogLanguage(inCatalogLanguage string) ApiSearchBriefBibsRequest {
	r.inCatalogLanguage = &inCatalogLanguage
	return r
}

// Limiter to restrict the response to the specified material type (mt index). (URL, LPS)
func (r ApiSearchBriefBibsRequest) MaterialType(materialType string) ApiSearchBriefBibsRequest {
	r.materialType = &materialType
	return r
}

// Limiter to restrict the response to the single OCLC symbol as the cataloging source (cs index). (OSL)
func (r ApiSearchBriefBibsRequest) CatalogSource(catalogSource string) ApiSearchBriefBibsRequest {
	r.catalogSource = &catalogSource
	return r
}

// Limiter to restrict the response to the single specified OCLC top-level facet type (x0 index). (book, image)
func (r ApiSearchBriefBibsRequest) ItemType(itemType []string) ApiSearchBriefBibsRequest {
	r.itemType = &itemType
	return r
}

// Limiter to restrict the response to the single specified OCLC sub facet type (x1 index). (dvd, digital)
func (r ApiSearchBriefBibsRequest) ItemSubType(itemSubType []string) ApiSearchBriefBibsRequest {
	r.itemSubType = &itemSubType
	return r
}

// Limiter to restrict the response to bibliographic records with a retention commitment (l8 index).
func (r ApiSearchBriefBibsRequest) RetentionCommitments(retentionCommitments bool) ApiSearchBriefBibsRequest {
	r.retentionCommitments = &retentionCommitments
	return r
}

// Limiter to restrict the response to bibliographic records associated with a particular shared print program (l8 index).
func (r ApiSearchBriefBibsRequest) SpProgram(spProgram string) ApiSearchBriefBibsRequest {
	r.spProgram = &spProgram
	return r
}

// The requested list of facets requested in the response
func (r ApiSearchBriefBibsRequest) Facets(facets []string) ApiSearchBriefBibsRequest {
	r.facets = &facets
	return r
}

// Whether or not to use FRBR grouping. Default is &#39;false&#39;
func (r ApiSearchBriefBibsRequest) GroupRelatedEditions(groupRelatedEditions bool) ApiSearchBriefBibsRequest {
	r.groupRelatedEditions = &groupRelatedEditions
	return r
}

// Whether or not to group variant records. Default is &#39;false&#39;
func (r ApiSearchBriefBibsRequest) GroupVariantRecords(groupVariantRecords bool) ApiSearchBriefBibsRequest {
	r.groupVariantRecords = &groupVariantRecords
	return r
}

// language user would prefer metadata description in
func (r ApiSearchBriefBibsRequest) PreferredLanguage(preferredLanguage string) ApiSearchBriefBibsRequest {
	r.preferredLanguage = &preferredLanguage
	return r
}

// whether or not to show holdings indicators in response
func (r ApiSearchBriefBibsRequest) ShowHoldingsIndicators(showHoldingsIndicators bool) ApiSearchBriefBibsRequest {
	r.showHoldingsIndicators = &showHoldingsIndicators
	return r
}

// result sort key
func (r ApiSearchBriefBibsRequest) OrderBy(orderBy string) ApiSearchBriefBibsRequest {
	r.orderBy = &orderBy
	return r
}

// start position of the bib records to return (0 based), default 0
func (r ApiSearchBriefBibsRequest) Offset(offset int32) ApiSearchBriefBibsRequest {
	r.offset = &offset
	return r
}

// maximum number of records to return, maximum 50, default 10
func (r ApiSearchBriefBibsRequest) Limit(limit int32) ApiSearchBriefBibsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchBriefBibsRequest) Execute() (*FindBibRetainedHoldings200Response, *http.Response, error) {
	return r.ApiService.SearchBriefBibsExecute(r)
}

/*
SearchBriefBibs Search Brief Bibliographic Resources

Search Bibliographic Resources. Key Indexes <table cellspacing="0"> <tbody><tr><th>Index Name</th> <th>Index Code</th> </tr> <tr><td>Author</td> <td>au</td> </tr><tr><td>Corporate/Conference Name</td> <td>cn</td> </tr><tr><td>ISBN</td> <td>bn</td> </tr><tr><td>ISSN</td> <td>in</td> </tr><tr><td>Keyword</td> <td>kw</td> </tr><tr><td>LCCN</td> <td>dn</td> </tr><tr><td>Notes</td> <td>nt</td> </tr><tr><td>OCLC Number</td> <td>sno</td> </tr><tr><td>Place of publication</td> <td>pl</td> </tr><tr><td>Publisher</td> <td>pb</td> </tr><tr><td>Series</td> <td>se</td> </tr><tr><td>Standard Number</td> <td>sn</td> </tr><tr><td>Subject</td> <td>su</td> </tr><tr><td>Title</td> <td>ti</td> </tr></tbody></table>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchBriefBibsRequest
*/
func (a *BibliographicResourcesApiService) SearchBriefBibs(ctx context.Context) ApiSearchBriefBibsRequest {
	return ApiSearchBriefBibsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FindBibRetainedHoldings200Response
func (a *BibliographicResourcesApiService) SearchBriefBibsExecute(r ApiSearchBriefBibsRequest) (*FindBibRetainedHoldings200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FindBibRetainedHoldings200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BibliographicResourcesApiService.SearchBriefBibs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/brief-bibs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.q == nil {
		return localVarReturnValue, nil, reportError("q is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	if r.deweyNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deweyNumber", r.deweyNumber, "csv")
	}
	if r.datePublished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "datePublished", r.datePublished, "csv")
	}
	if r.heldByGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heldByGroup", r.heldByGroup, "")
	}
	if r.heldBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heldBy", r.heldBy, "")
	}
	if r.heldBySymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heldBySymbol", r.heldBySymbol, "csv")
	}
	if r.heldByInstitutionID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heldByInstitutionID", r.heldByInstitutionID, "csv")
	}
	if r.inLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inLanguage", r.inLanguage, "csv")
	}
	if r.inCatalogLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inCatalogLanguage", r.inCatalogLanguage, "")
	}
	if r.materialType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "materialType", r.materialType, "")
	}
	if r.catalogSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "catalogSource", r.catalogSource, "")
	}
	if r.itemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemType", r.itemType, "csv")
	}
	if r.itemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemSubType", r.itemSubType, "csv")
	}
	if r.retentionCommitments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retentionCommitments", r.retentionCommitments, "")
	}
	if r.spProgram != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spProgram", r.spProgram, "")
	}
	if r.facets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "facets", r.facets, "csv")
	}
	if r.groupRelatedEditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupRelatedEditions", r.groupRelatedEditions, "")
	}
	if r.groupVariantRecords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupVariantRecords", r.groupVariantRecords, "")
	}
	if r.preferredLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preferredLanguage", r.preferredLanguage, "")
	}
	if r.showHoldingsIndicators != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showHoldingsIndicators", r.showHoldingsIndicators, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v FindBibRetainedHoldings400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
